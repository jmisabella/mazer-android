package com.jmisabella.mazeq

import android.content.Context
import android.media.AudioManager
import android.media.ToneGenerator
import android.os.Bundle
import android.os.VibrationEffect
import android.os.Vibrator
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import com.jmisabella.mazeq.layout.CellColors
import com.jmisabella.mazeq.models.*
import com.jmisabella.mazeq.screens.MazeRenderScreen
import com.jmisabella.mazeq.screens.MazeRequestScreen
import com.jmisabella.mazeq.ui.theme.MazerTheme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.util.UUID
import android.util.DisplayMetrics
import kotlin.math.floor
import kotlin.math.sqrt

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MazerTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    ContentScreen()
                }
            }
        }
    }
}

@Composable
fun ContentScreen() {
    val coroutineScope = rememberCoroutineScope()
    val context = LocalContext.current
    val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
    val toneGenerator = ToneGenerator(AudioManager.STREAM_MUSIC, 100)

    var ffiIntegrationTestResult by remember { mutableStateOf(0) }
    var mazeCells by remember { mutableStateOf<List<MazeCell>>(emptyList()) }
    var mazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
    var mazeGenerated by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf<String?>(null) }

    var selectedSize by remember { mutableStateOf(CellSize.LARGE) }
    var selectedMazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
    var selectedAlgorithm by remember { mutableStateOf(MazeAlgorithm.RECURSIVE_BACKTRACKER) }
    var showSolution by remember { mutableStateOf(false) }
    var showHeatMap by remember { mutableStateOf(false) }
    var showControls by remember { mutableStateOf(false) }
    var padOffset by remember { mutableStateOf(Offset.Zero) }
    var showCelebration by remember { mutableStateOf(false) }
    var selectedPalette by remember { mutableStateOf(allPalettes.randomOrNull() ?: turquoisePalette) }
    var mazeID by remember { mutableStateOf(UUID.randomUUID().toString()) }
    var currentGrid by remember { mutableStateOf<Long?>(null) } // Grid* as Long
    var defaultBackgroundColor by remember { mutableStateOf<Color>(CellColors.defaultBackgroundColors.randomOrNull() ?: Color.White) }
    var didInitialRandomization by remember { mutableStateOf(false) }
    var hasPlayedSoundThisSession by remember { mutableStateOf(false) }
    var captureSteps by remember { mutableStateOf(false) }
    var isGeneratingMaze by remember { mutableStateOf(false) }
    var isAnimatingGeneration by remember { mutableStateOf(false) }
    var generationSteps by remember { mutableStateOf<List<List<MazeCell>>>(emptyList()) }
    var isLoading by remember { mutableStateOf(false) }
    var optionalColor by remember { mutableStateOf<Color?>(null) }
    var showHelp by remember { mutableStateOf(false) }

    // Load saved preferences
    LaunchedEffect(Unit) {
        val sharedPrefs = context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
        selectedSize = CellSize.values().find { it.value == sharedPrefs.getInt("lastSize", CellSize.MEDIUM.value) } ?: CellSize.MEDIUM
        selectedMazeType = MazeType.values().find { it.ffiName == sharedPrefs.getString("lastMazeType", MazeType.ORTHOGONAL.ffiName) } ?: MazeType.ORTHOGONAL
        selectedAlgorithm = MazeAlgorithm.values().find { it.name == sharedPrefs.getString("lastAlgorithm", MazeAlgorithm.RECURSIVE_BACKTRACKER.name) } ?: MazeAlgorithm.RECURSIVE_BACKTRACKER
        showHeatMap = sharedPrefs.getBoolean("showHeatMap", false)

        // Save initial preferences
        sharedPrefs.edit().apply {
            putInt("lastSize", selectedSize.value)
            putString("lastMazeType", selectedMazeType.ffiName)
            putString("lastAlgorithm", selectedAlgorithm.name)
            putBoolean("showHeatMap", showHeatMap)
            apply()
        }

        // Run FFI integration test
        ffiIntegrationTestResult = MazerNative.mazerFfiIntegrationTest()
        println("mazer_ffi_integration_test returned: $ffiIntegrationTestResult")
        if (ffiIntegrationTestResult == 42) {
            println("FFI integration test passed ✅")
        } else {
            println("FFI integration test failed ❌")
        }
    }

    // Save preferences on change
    LaunchedEffect(selectedSize) {
        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
            .edit()
            .putInt("lastSize", selectedSize.value)
            .apply()
    }
    LaunchedEffect(selectedMazeType) {
        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
            .edit()
            .putString("lastMazeType", selectedMazeType.ffiName)
            .apply()
    }
    LaunchedEffect(selectedAlgorithm) {
        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
            .edit()
            .putString("lastAlgorithm", selectedAlgorithm.name)
            .apply()
    }
    LaunchedEffect(showHeatMap) {
        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
            .edit()
            .putBoolean("showHeatMap", showHeatMap)
            .apply()
    }

    // Compute cell sizes
    fun computeCellSizes(mazeType: MazeType, cellSize: CellSize): Pair<Float, Float> {
        val baseSize = when (cellSize) {
            CellSize.TINY -> 12f
            CellSize.SMALL -> 20f
            CellSize.MEDIUM -> 30f
            CellSize.LARGE -> 40f
        }
        return when (mazeType) {
            MazeType.UPSILON -> baseSize to baseSize * 0.8f
            else -> baseSize to baseSize
        }
    }

    // Random palette selection excluding current
    fun randomPaletteExcluding(current: HeatMapPalette, allPalettes: List<HeatMapPalette>): HeatMapPalette {
        val availablePalettes = allPalettes.filter { it != current }
        return availablePalettes.randomOrNull() ?: current
    }

    // Random default background color excluding current
    fun randomDefaultExcluding(current: Color, all: List<Color>): Color {
        val others = all.filter { it != current }
        return others.randomOrNull() ?: current
    }

    // Cleanup maze data
    fun cleanupMazeData() {
        currentGrid?.let { gridPtr ->
            MazerNative.destroyMaze(gridPtr)
            currentGrid = null
        }
        mazeCells = emptyList()
        generationSteps = emptyList()
        mazeGenerated = false
        isAnimatingGeneration = false
    }

    // Submit maze request
    fun submitMazeRequest() {
        coroutineScope.launch {
            isLoading = true
            withContext(Dispatchers.IO) {
                // Cleanup existing grid
                currentGrid?.let { gridPtr ->
                    MazerNative.destroyMaze(gridPtr)
                    currentGrid = null
                }

                val (squareCellSize, octagonCellSize) = computeCellSizes(selectedMazeType, selectedSize)

                // Get screen dimensions
                val metrics = context.resources.displayMetrics
                val screenH = metrics.heightPixels / metrics.density
                val screenW = metrics.widthPixels / metrics.density
                val isSmallDevice = screenH <= 667

                val perSidePad: Float = when (selectedMazeType) {
                    MazeType.ORTHOGONAL -> 20f
                    MazeType.UPSILON -> 12f
                    else -> if (isSmallDevice) 50f else 100f
                }

                val totalVerticalPadding = perSidePad * 2
                val controlArea = 80f
                val availableH = screenH - controlArea - totalVerticalPadding
                val drawableH = availableH // Simplified; adjust for insets if needed

                val cellSize = if (selectedMazeType == MazeType.UPSILON) octagonCellSize else squareCellSize
                val spacing = if (selectedMazeType == MazeType.UPSILON) (sqrt(2f) * 0.5f) * octagonCellSize else cellSize
                val rowHeight = if (selectedMazeType == MazeType.UPSILON) octagonCellSize * (sqrt(2f) * 0.5f) else cellSize

                val maxHeightRows = maxOf(1, floor(availableH / rowHeight).toInt())
                val maxWidth = maxOf(1, floor(screenW / spacing).toInt())

                var finalWidth: Int
                var finalHeight: Int

                if (selectedMazeType == MazeType.RHOMBIC) {
                    val s = squareCellSize
                    val diag = s * sqrt(2f)
                    val pitch = diag * 0.5f
                    finalWidth = maxOf(1, floor(screenW / diag).toInt())
                    finalHeight = maxOf(1, floor(drawableH / pitch).toInt())
                } else {
                    finalWidth = if (selectedMazeType == MazeType.SIGMA) maxWidth / 3 else maxWidth
                    finalHeight = if (selectedMazeType == MazeType.SIGMA) maxHeightRows / 3 else maxHeightRows
                }

                if (captureSteps && (finalWidth > 100 || finalHeight > 100)) {
                    withContext(Dispatchers.Main) {
                        errorMessage = "Show Maze Generation is only available for mazes with width and height ≤ 100."
                        isLoading = false
                    }
                    return@withContext
                }

                val mazeRequest = MazeRequest(
                    mazeType = selectedMazeType,
                    width = finalWidth,
                    height = finalHeight,
                    algorithm = selectedAlgorithm,
                    captureSteps = captureSteps
                )

                val jsonString = Json.encodeToString(mazeRequest)
                println("Valid JSON: $jsonString")

                val gridPtr = MazerNative.generateMaze(jsonString)
                if (gridPtr == 0L) {
                    withContext(Dispatchers.Main) {
                        errorMessage = "Failed to generate maze."
                        isLoading = false
                    }
                    return@withContext
                }

                currentGrid = gridPtr

                val cellsPtr = MazerNative.getCells(gridPtr)
                if (cellsPtr == null) {
                    withContext(Dispatchers.Main) {
                        errorMessage = "Failed to retrieve cells."
                        isLoading = false
                    }
                    return@withContext
                }

                val cells = cellsPtr.map { ffiCell ->
                    MazeCell(
                        x = ffiCell.x.toInt(),
                        y = ffiCell.y.toInt(),
                        mazeType = ffiCell.mazeType ?: "",
                        linked = ffiCell.linked?.toList() ?: emptyList(),
                        distance = ffiCell.distance,
                        isStart = ffiCell.isStart,
                        isGoal = ffiCell.isGoal,
                        isActive = ffiCell.isActive,
                        isVisited = ffiCell.isVisited,
                        hasBeenVisited = ffiCell.hasBeenVisited,
                        onSolutionPath = ffiCell.onSolutionPath,
                        orientation = ffiCell.orientation ?: "",
                        isSquare = ffiCell.isSquare
                    )
                }

                var steps: List<List<MazeCell>> = emptyList()
                if (captureSteps) {
                    val stepsCount = MazerNative.getGenerationStepsCount(gridPtr)
                    steps = (0 until stepsCount).mapNotNull { stepIndex ->
                        val stepCellsPtr = MazerNative.getGenerationStepCells(gridPtr, stepIndex)
                        if (stepCellsPtr == null) {
                            withContext(Dispatchers.Main) {
                                errorMessage = "Failed to retrieve generation step cells."
                                isLoading = false
                            }
                            null
                        } else {
                            val stepCells = stepCellsPtr.map { ffiCell ->
                                MazeCell(
                                    x = ffiCell.x.toInt(),
                                    y = ffiCell.y.toInt(),
                                    mazeType = ffiCell.mazeType ?: "",
                                    linked = ffiCell.linked?.toList() ?: emptyList(),
                                    distance = ffiCell.distance,
                                    isStart = ffiCell.isStart,
                                    isGoal = ffiCell.isGoal,
                                    isActive = ffiCell.isActive,
                                    isVisited = ffiCell.isVisited,
                                    hasBeenVisited = ffiCell.hasBeenVisited,
                                    onSolutionPath = ffiCell.onSolutionPath,
                                    orientation = ffiCell.orientation ?: "",
                                    isSquare = ffiCell.isSquare
                                )
                            }
                            stepCells
                        }
                    }
                }

                withContext(Dispatchers.Main) {
                    mazeCells = cells
                    mazeType = MazeType.fromFFIName(cells.firstOrNull()?.mazeType) ?: MazeType.ORTHOGONAL
                    if (captureSteps) {
                        generationSteps = steps
                        isAnimatingGeneration = true
                    } else {
                        mazeGenerated = true
                    }
                    optionalColor = if ((0..1).random() == 1) {
                        listOf(Color.Magenta, Color.Gray, Color.Yellow, Color.Blue, Color(0xFFA200FF), Color(0xFFFF9500)).randomOrNull()
                    } else null
                    isLoading = false
                    errorMessage = null
                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
                }
            }
        }
    }

    // Celebrate victory
    fun celebrateVictory() {
        showCelebration = true
        captureSteps = false

        vibrator.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE))
        toneGenerator.startTone(ToneGenerator.TONE_CDMA_CONFIRM, 200)

        coroutineScope.launch {
            kotlinx.coroutines.delay(3000)
            withContext(Dispatchers.Main) {
                showCelebration = false
                if (mazeGenerated) {
                    showSolution = false
                    mazeID = UUID.randomUUID().toString()
                    submitMazeRequest()
                }
            }
        }
    }

    // Perform move
    fun performMove(direction: String) {
        if (showCelebration) return

        val gridPtr = currentGrid ?: return

        val tryDirections = when (mazeType) {
            MazeType.ORTHOGONAL -> listOf(direction)
            MazeType.DELTA -> when (direction) {
                "UpperRight" -> listOf("UpperRight", "Right")
                "LowerRight" -> listOf("LowerRight", "Right")
                "UpperLeft" -> listOf("UpperLeft", "Left")
                "LowerLeft" -> listOf("LowerLeft", "Left")
                else -> listOf(direction)
            }
            MazeType.SIGMA -> when (direction) {
                "UpperRight" -> listOf("UpperRight", "LowerRight")
                "LowerRight" -> listOf("LowerRight", "UpperRight")
                "UpperLeft" -> listOf("UpperLeft", "LowerLeft")
                "LowerLeft" -> listOf("LowerLeft", "UpperLeft")
                else -> listOf(direction)
            }
            MazeType.UPSILON -> listOf(direction)
            MazeType.RHOMBIC -> listOf(direction)
        }

        var newGridPtr: Long? = null
        for (dir in tryDirections) {
            newGridPtr = MazerNative.makeMove(gridPtr, dir)
            if (newGridPtr != 0L) break
        }

        if (newGridPtr == null || newGridPtr == 0L) return

        toneGenerator.startTone(ToneGenerator.TONE_PROP_BEEP, 200)
        vibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))

        currentGrid = newGridPtr
        val cellsPtr = MazerNative.getCells(newGridPtr)
        if (cellsPtr == null) {
            errorMessage = "Failed to retrieve updated maze."
            return
        }

        val cells = cellsPtr.map { ffiCell ->
            MazeCell(
                x = ffiCell.x.toInt(),
                y = ffiCell.y.toInt(),
                mazeType = ffiCell.mazeType ?: "",
                linked = ffiCell.linked?.toList() ?: emptyList(),
                distance = ffiCell.distance,
                isStart = ffiCell.isStart,
                isGoal = ffiCell.isGoal,
                isActive = ffiCell.isActive,
                isVisited = ffiCell.isVisited,
                hasBeenVisited = ffiCell.hasBeenVisited,
                onSolutionPath = ffiCell.onSolutionPath,
                orientation = ffiCell.orientation ?: "",
                isSquare = ffiCell.isSquare
            )
        }

        mazeCells = cells

        if (!showCelebration && cells.any { it.isGoal && it.isActive }) {
            celebrateVictory()
        }
    }


    // Main content rendering
    if (isGeneratingMaze) {
        CircularProgressIndicator(modifier = Modifier.fillMaxSize())
    } else if (isAnimatingGeneration) {
        Text("Maze Generation Animation Placeholder") // TODO: Implement MazeGenerationAnimationScreen
    } else if (mazeGenerated) {
        MazeRenderScreen(
            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
            showSolution = remember { mutableStateOf(showSolution) },
            showHeatMap = remember { mutableStateOf(showHeatMap) },
            showControls = remember { mutableStateOf(showControls) },
            padOffset = remember { mutableStateOf(padOffset) },
            selectedPalette = remember { mutableStateOf(selectedPalette) },
            mazeID = mazeID,
            defaultBackground = remember { mutableStateOf(defaultBackgroundColor) },
            showHelp = remember { mutableStateOf(showHelp) },
            mazeCells = mazeCells,
            mazeType = mazeType,
            cellSize = selectedSize,
            optionalColor = optionalColor,
            regenerateMaze = { submitMazeRequest() },
            moveAction = { direction -> performMove(direction) },
            cellSizes = computeCellSizes(selectedMazeType, selectedSize),
            toggleHeatMap = {
                showHeatMap = !showHeatMap
                if (showHeatMap) {
                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
                }
            },
            cleanupMazeData = { cleanupMazeData() }
        )
    } else {
        MazeRequestScreen(
            mazeCells = remember { mutableStateOf(mazeCells) },
            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
            mazeType = remember { mutableStateOf(mazeType) },
            selectedSize = remember { mutableStateOf(selectedSize) },
            selectedMazeType = remember { mutableStateOf(selectedMazeType) },
            selectedAlgorithm = remember { mutableStateOf(selectedAlgorithm) },
            captureSteps = remember { mutableStateOf(captureSteps) },
            submitMazeRequest = { submitMazeRequest() }
        )
    }

    if (isLoading) {
        Text("Loading...")
    }
    if (showHelp) {
        Text("Help Modal Placeholder") // TODO: Implement HelpModalScreen
    }
    if (showCelebration) {
        Text("Celebration Placeholder") // TODO: Implement SparkleScreen
    }
}

//package com.jmisabella.mazeq
//
//import android.content.Context
//import android.media.AudioManager
//import android.media.ToneGenerator
//import android.os.Bundle
//import android.os.VibrationEffect
//import android.os.Vibrator
//import androidx.activity.ComponentActivity
//import androidx.activity.compose.setContent
//import androidx.compose.foundation.layout.fillMaxSize
//import androidx.compose.material3.CircularProgressIndicator
//import androidx.compose.material3.MaterialTheme
//import androidx.compose.material3.Surface
//import androidx.compose.material3.Text
//import androidx.compose.runtime.*
//import androidx.compose.ui.Modifier
//import androidx.compose.ui.geometry.Offset
//import androidx.compose.ui.graphics.Color
//import androidx.compose.ui.platform.LocalContext
//import com.jmisabella.mazeq.layout.CellColors
//import com.jmisabella.mazeq.models.*
//import com.jmisabella.mazeq.screens.MazeRenderScreen
//import com.jmisabella.mazeq.screens.MazeRequestScreen
//import com.jmisabella.mazeq.ui.theme.MazerTheme
//import kotlinx.coroutines.Dispatchers
//import kotlinx.coroutines.launch
//import kotlinx.coroutines.withContext
//import kotlinx.serialization.encodeToString
//import kotlinx.serialization.json.Json
//import java.util.UUID
//import android.util.DisplayMetrics
//import kotlin.math.floor
//import kotlin.math.sqrt
//
//class MainActivity : ComponentActivity() {
//    override fun onCreate(savedInstanceState: Bundle?) {
//        super.onCreate(savedInstanceState)
//        setContent {
//            MazerTheme {
//                Surface(
//                    modifier = Modifier.fillMaxSize(),
//                    color = MaterialTheme.colorScheme.background
//                ) {
//                    ContentScreen()
//                }
//            }
//        }
//    }
//}
//
//@Composable
//fun ContentScreen() {
//    val coroutineScope = rememberCoroutineScope()
//    val context = LocalContext.current
//    val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
//    val toneGenerator = ToneGenerator(AudioManager.STREAM_MUSIC, 100)
//
//    var ffiIntegrationTestResult by remember { mutableStateOf(0) }
//    var mazeCells by remember { mutableStateOf<List<MazeCell>>(emptyList()) }
//    var mazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
//    var mazeGenerated by remember { mutableStateOf(false) }
//    var errorMessage by remember { mutableStateOf<String?>(null) }
//
//    var selectedSize by remember { mutableStateOf(CellSize.LARGE) }
//    var selectedMazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
//    var selectedAlgorithm by remember { mutableStateOf(MazeAlgorithm.RECURSIVE_BACKTRACKER) }
//    var showSolution by remember { mutableStateOf(false) }
//    var showHeatMap by remember { mutableStateOf(false) }
//    var showControls by remember { mutableStateOf(false) }
//    var padOffset by remember { mutableStateOf(Offset.Zero) }
//    var showCelebration by remember { mutableStateOf(false) }
//    var selectedPalette by remember { mutableStateOf(allPalettes.randomOrNull() ?: turquoisePalette) }
//    var mazeID by remember { mutableStateOf(UUID.randomUUID().toString()) }
//    var currentGrid by remember { mutableStateOf<Long?>(null) } // Grid* as Long
//    var defaultBackgroundColor by remember { mutableStateOf<Color>(CellColors.defaultBackgroundColors.randomOrNull() ?: Color.White) }
//    var didInitialRandomization by remember { mutableStateOf(false) }
//    var hasPlayedSoundThisSession by remember { mutableStateOf(false) }
//    var captureSteps by remember { mutableStateOf(false) }
//    var isGeneratingMaze by remember { mutableStateOf(false) }
//    var isAnimatingGeneration by remember { mutableStateOf(false) }
//    var generationSteps by remember { mutableStateOf<List<List<MazeCell>>>(emptyList()) }
//    var isLoading by remember { mutableStateOf(false) }
//    var optionalColor by remember { mutableStateOf<Color?>(null) }
//    var showHelp by remember { mutableStateOf(false) }
//
//    // Compute cell sizes
//    fun computeCellSizes(mazeType: MazeType, cellSize: CellSize): Pair<Float, Float> {
//        val baseSize = when (cellSize) {
//            CellSize.TINY -> 12f
//            CellSize.SMALL -> 20f
//            CellSize.MEDIUM -> 30f
//            CellSize.LARGE -> 40f
//        }
//        return when (mazeType) {
//            MazeType.UPSILON -> baseSize to baseSize * 0.8f
//            else -> baseSize to baseSize
//        }
//    }
//
//    // Random palette selection excluding current
//    fun randomPaletteExcluding(current: HeatMapPalette, allPalettes: List<HeatMapPalette>): HeatMapPalette {
//        val availablePalettes = allPalettes.filter { it != current }
//        return availablePalettes.randomOrNull() ?: current
//    }
//
//    // Random default background color excluding current
//    fun randomDefaultExcluding(current: Color, all: List<Color>): Color {
//        val others = all.filter { it != current }
//        return others.randomOrNull() ?: current
//    }
//
//    // Cleanup maze data
//    fun cleanupMazeData() {
//        currentGrid?.let { gridPtr ->
//            MazerNative.destroyMaze(gridPtr)
//            currentGrid = null
//        }
//        mazeCells = emptyList()
//        generationSteps = emptyList()
//        mazeGenerated = false
//        isAnimatingGeneration = false
//    }
//
//    // Celebrate victory
//    fun celebrateVictory() {
//        showCelebration = true
//        captureSteps = false
//
//        vibrator.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE))
//        toneGenerator.startTone(ToneGenerator.TONE_CDMA_CONFIRM, 200)
//
//        coroutineScope.launch {
//            kotlinx.coroutines.delay(3000)
//            withContext(Dispatchers.Main) {
//                showCelebration = false
//                if (mazeGenerated) {
//                    showSolution = false
//                    mazeID = UUID.randomUUID().toString()
//                    submitMazeRequest()
//                }
//            }
//        }
//    }
//
//    // Perform move
//    fun performMove(direction: String) {
//        if (showCelebration) return
//
//        val gridPtr = currentGrid ?: return
//
//        val tryDirections = when (mazeType) {
//            MazeType.ORTHOGONAL -> listOf(direction)
//            MazeType.DELTA -> when (direction) {
//                "UpperRight" -> listOf("UpperRight", "Right")
//                "LowerRight" -> listOf("LowerRight", "Right")
//                "UpperLeft" -> listOf("UpperLeft", "Left")
//                "LowerLeft" -> listOf("LowerLeft", "Left")
//                else -> listOf(direction)
//            }
//            MazeType.SIGMA -> when (direction) {
//                "UpperRight" -> listOf("UpperRight", "LowerRight")
//                "LowerRight" -> listOf("LowerRight", "UpperRight")
//                "UpperLeft" -> listOf("UpperLeft", "LowerLeft")
//                "LowerLeft" -> listOf("LowerLeft", "UpperLeft")
//                else -> listOf(direction)
//            }
//            MazeType.UPSILON -> listOf(direction)
//            MazeType.RHOMBIC -> listOf(direction)
//        }
//
//        var newGridPtr: Long? = null
//        for (dir in tryDirections) {
//            newGridPtr = MazerNative.makeMove(gridPtr, dir)
//            if (newGridPtr != 0L) break
//        }
//
//        if (newGridPtr == null || newGridPtr == 0L) return
//
//        toneGenerator.startTone(ToneGenerator.TONE_PROP_BEEP, 200)
//        vibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))
//
//        currentGrid = newGridPtr
//        val cellsPtr = MazerNative.getCells(newGridPtr)
//        if (cellsPtr == null) {
//            errorMessage = "Failed to retrieve updated maze."
//            return
//        }
//
//        val cells = cellsPtr.map { ffiCell ->
//            MazeCell(
//                x = ffiCell.x.toInt(),
//                y = ffiCell.y.toInt(),
//                mazeType = ffiCell.mazeType ?: "",
//                linked = ffiCell.linked?.toList() ?: emptyList(),
//                distance = ffiCell.distance,
//                isStart = ffiCell.isStart,
//                isGoal = ffiCell.isGoal,
//                isActive = ffiCell.isActive,
//                isVisited = ffiCell.isVisited,
//                hasBeenVisited = ffiCell.hasBeenVisited,
//                onSolutionPath = ffiCell.onSolutionPath,
//                orientation = ffiCell.orientation ?: "",
//                isSquare = ffiCell.isSquare
//            )
//        }
//
//        MazerNative.mazerFreeCells(cellsPtr, cellsPtr.size.toLong())
//
//        mazeCells = cells
//
//        if (!showCelebration && cells.any { it.isGoal && it.isActive }) {
//            celebrateVictory()
//        }
//    }
//
//    // Submit maze request
//    fun submitMazeRequest() {
//        coroutineScope.launch {
//            isLoading = true
//            withContext(Dispatchers.IO) {
//                // Cleanup existing grid
//                currentGrid?.let { gridPtr ->
//                    MazerNative.destroyMaze(gridPtr)
//                    currentGrid = null
//                }
//
//                val (squareCellSize, octagonCellSize) = computeCellSizes(selectedMazeType, selectedSize)
//
//                // Get screen dimensions
//                val metrics = context.resources.displayMetrics
//                val screenH = metrics.heightPixels / metrics.density
//                val screenW = metrics.widthPixels / metrics.density
//                val isSmallDevice = screenH <= 667
//
//                val perSidePad: Float = when (selectedMazeType) {
//                    MazeType.ORTHOGONAL -> 20f
//                    MazeType.UPSILON -> 12f
//                    else -> if (isSmallDevice) 50f else 100f
//                }
//
//                val totalVerticalPadding = perSidePad * 2
//                val controlArea = 80f
//                val availableH = screenH - controlArea - totalVerticalPadding
//                val drawableH = availableH // Simplified; adjust for insets if needed
//
//                val cellSize = if (selectedMazeType == MazeType.UPSILON) octagonCellSize else squareCellSize
//                val spacing = if (selectedMazeType == MazeType.UPSILON) (sqrt(2f) * 0.5f) * octagonCellSize else cellSize
//                val rowHeight = if (selectedMazeType == MazeType.UPSILON) octagonCellSize * (sqrt(2f) * 0.5f) else cellSize
//
//                val maxHeightRows = maxOf(1, floor(availableH / rowHeight).toInt())
//                val maxWidth = maxOf(1, floor(screenW / spacing).toInt())
//
//                var finalWidth: Int
//                var finalHeight: Int
//
//                if (selectedMazeType == MazeType.RHOMBIC) {
//                    val s = squareCellSize
//                    val diag = s * sqrt(2f)
//                    val pitch = diag * 0.5f
//                    finalWidth = maxOf(1, floor(screenW / diag).toInt())
//                    finalHeight = maxOf(1, floor(drawableH / pitch).toInt())
//                } else {
//                    finalWidth = if (selectedMazeType == MazeType.SIGMA) maxWidth / 3 else maxWidth
//                    finalHeight = if (selectedMazeType == MazeType.SIGMA) maxHeightRows / 3 else maxHeightRows
//                }
//
//                if (captureSteps && (finalWidth > 100 || finalHeight > 100)) {
//                    withContext(Dispatchers.Main) {
//                        errorMessage = "Show Maze Generation is only available for mazes with width and height ≤ 100."
//                        isLoading = false
//                    }
//                    return@withContext
//                }
//
//                val mazeRequest = MazeRequest(
//                    mazeType = selectedMazeType,
//                    width = finalWidth,
//                    height = finalHeight,
//                    algorithm = selectedAlgorithm,
//                    captureSteps = captureSteps
//                )
//
//                val jsonString = Json.encodeToString(mazeRequest)
//                println("Valid JSON: $jsonString")
//
//                val gridPtr = MazerNative.generateMaze(jsonString)
//                if (gridPtr == 0L) {
//                    withContext(Dispatchers.Main) {
//                        errorMessage = "Failed to generate maze."
//                        isLoading = false
//                    }
//                    return@withContext
//                }
//
//                currentGrid = gridPtr
//
//                val cellsPtr = MazerNative.getCells(gridPtr)
//                if (cellsPtr == null) {
//                    withContext(Dispatchers.Main) {
//                        errorMessage = "Failed to retrieve cells."
//                        isLoading = false
//                    }
//                    return@withContext
//                }
//
//                val cells = cellsPtr.map { ffiCell ->
//                    MazeCell(
//                        x = ffiCell.x.toInt(),
//                        y = ffiCell.y.toInt(),
//                        mazeType = ffiCell.mazeType ?: "",
//                        linked = ffiCell.linked?.toList() ?: emptyList(),
//                        distance = ffiCell.distance,
//                        isStart = ffiCell.isStart,
//                        isGoal = ffiCell.isGoal,
//                        isActive = ffiCell.isActive,
//                        isVisited = ffiCell.isVisited,
//                        hasBeenVisited = ffiCell.hasBeenVisited,
//                        onSolutionPath = ffiCell.onSolutionPath,
//                        orientation = ffiCell.orientation ?: "",
//                        isSquare = ffiCell.isSquare
//                    )
//                }
//
//                MazerNative.mazerFreeCells(cellsPtr, cellsPtr.size.toLong())
//
//                var steps: List<List<MazeCell>> = emptyList()
//                if (captureSteps) {
//                    val stepsCount = MazerNative.getGenerationStepsCount(gridPtr)
//                    steps = (0 until stepsCount).mapNotNull { stepIndex ->
//                        val stepCellsPtr = MazerNative.getGenerationStepCells(gridPtr, stepIndex)
//                        if (stepCellsPtr == null) {
//                            withContext(Dispatchers.Main) {
//                                errorMessage = "Failed to retrieve generation step cells."
//                                isLoading = false
//                            }
//                            null
//                        } else {
//                            val stepCells = stepCellsPtr.map { ffiCell ->
//                                MazeCell(
//                                    x = ffiCell.x.toInt(),
//                                    y = ffiCell.y.toInt(),
//                                    mazeType = ffiCell.mazeType ?: "",
//                                    linked = ffiCell.linked?.toList() ?: emptyList(),
//                                    distance = ffiCell.distance,
//                                    isStart = ffiCell.isStart,
//                                    isGoal = ffiCell.isGoal,
//                                    isActive = ffiCell.isActive,
//                                    isVisited = ffiCell.isVisited,
//                                    hasBeenVisited = ffiCell.hasBeenVisited,
//                                    onSolutionPath = ffiCell.onSolutionPath,
//                                    orientation = ffiCell.orientation ?: "",
//                                    isSquare = ffiCell.isSquare
//                                )
//                            }
//                            MazerNative.mazerFreeCells(stepCellsPtr, stepCellsPtr.size.toLong())
//                            stepCells
//                        }
//                    }
//                }
//
//                withContext(Dispatchers.Main) {
//                    mazeCells = cells
//                    mazeType = MazeType.fromFFIName(cells.firstOrNull()?.mazeType) ?: MazeType.ORTHOGONAL
//                    if (captureSteps) {
//                        generationSteps = steps
//                        isAnimatingGeneration = true
//                    } else {
//                        mazeGenerated = true
//                    }
//                    optionalColor = if ((0..1).random() == 1) {
//                        listOf(Color.Magenta, Color.Gray, Color.Yellow, Color.Blue, Color(0xFFA200FF), Color(0xFFFF9500)).randomOrNull()
//                    } else null
//                    isLoading = false
//                    errorMessage = null
//                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
//                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
//                }
//            }
//        }
//    }
//
//    // Load saved preferences
//    LaunchedEffect(Unit) {
//        val sharedPrefs = context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//        selectedSize = CellSize.values().find { it.value == sharedPrefs.getInt("lastSize", CellSize.MEDIUM.value) } ?: CellSize.MEDIUM
//        selectedMazeType = MazeType.values().find { it.ffiName == sharedPrefs.getString("lastMazeType", MazeType.ORTHOGONAL.ffiName) } ?: MazeType.ORTHOGONAL
//        selectedAlgorithm = MazeAlgorithm.values().find { it.name == sharedPrefs.getString("lastAlgorithm", MazeAlgorithm.RECURSIVE_BACKTRACKER.name) } ?: MazeAlgorithm.RECURSIVE_BACKTRACKER
//        showHeatMap = sharedPrefs.getBoolean("showHeatMap", false)
//
//        // Save initial preferences
//        sharedPrefs.edit().apply {
//            putInt("lastSize", selectedSize.value)
//            putString("lastMazeType", selectedMazeType.ffiName)
//            putString("lastAlgorithm", selectedAlgorithm.name)
//            putBoolean("showHeatMap", showHeatMap)
//            apply()
//        }
//
//        // Run FFI integration test
//        ffiIntegrationTestResult = MazerNative.mazerFfiIntegrationTest()
//        println("mazer_ffi_integration_test returned: $ffiIntegrationTestResult")
//        if (ffiIntegrationTestResult == 42) {
//            println("FFI integration test passed ✅")
//        } else {
//            println("FFI integration test failed ❌")
//        }
//    }
//
//    // Save preferences on change
//    LaunchedEffect(selectedSize) {
//        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//            .edit()
//            .putInt("lastSize", selectedSize.value)
//            .apply()
//    }
//    LaunchedEffect(selectedMazeType) {
//        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//            .edit()
//            .putString("lastMazeType", selectedMazeType.ffiName)
//            .apply()
//    }
//    LaunchedEffect(selectedAlgorithm) {
//        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//            .edit()
//            .putString("lastAlgorithm", selectedAlgorithm.name)
//            .apply()
//    }
//    LaunchedEffect(showHeatMap) {
//        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//            .edit()
//            .putBoolean("showHeatMap", showHeatMap)
//            .apply()
//    }
//
//    // Main content rendering
//    if (isGeneratingMaze) {
//        CircularProgressIndicator(modifier = Modifier.fillMaxSize())
//    } else if (isAnimatingGeneration) {
//        Text("Maze Generation Animation Placeholder") // TODO: Implement MazeGenerationAnimationScreen
//    } else if (mazeGenerated) {
//        MazeRenderScreen(
//            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
//            showSolution = remember { mutableStateOf(showSolution) },
//            showHeatMap = remember { mutableStateOf(showHeatMap) },
//            showControls = remember { mutableStateOf(showControls) },
//            padOffset = remember { mutableStateOf(padOffset) },
//            selectedPalette = remember { mutableStateOf(selectedPalette) },
//            mazeID = mazeID,
//            defaultBackground = remember { mutableStateOf(defaultBackgroundColor) },
//            showHelp = remember { mutableStateOf(showHelp) },
//            mazeCells = mazeCells,
//            mazeType = mazeType,
//            cellSize = selectedSize,
//            optionalColor = optionalColor,
//            regenerateMaze = ::submitMazeRequest,
//            moveAction = ::performMove,
//            cellSizes = computeCellSizes(selectedMazeType, selectedSize),
//            toggleHeatMap = {
//                showHeatMap = !showHeatMap
//                if (showHeatMap) {
//                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
//                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
//                }
//            },
//            cleanupMazeData = ::cleanupMazeData
//        )
//    } else {
//        MazeRequestScreen(
//            mazeCells = remember { mutableStateOf(mazeCells) },
//            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
//            mazeType = remember { mutableStateOf(mazeType) },
//            selectedSize = remember { mutableStateOf(selectedSize) },
//            selectedMazeType = remember { mutableStateOf(selectedMazeType) },
//            selectedAlgorithm = remember { mutableStateOf(selectedAlgorithm) },
//            captureSteps = remember { mutableStateOf(captureSteps) },
//            submitMazeRequest = ::submitMazeRequest
//        )
//    }
//
//    if (isLoading) {
//        Text("Loading...")
//    }
//    if (showHelp) {
//        Text("Help Modal Placeholder") // TODO: Implement HelpModalScreen
//    }
//    if (showCelebration) {
//        Text("Celebration Placeholder") // TODO: Implement SparkleScreen
//    }
//}
//
////package com.jmisabella.mazeq
////
////import android.content.Context
////import android.media.AudioManager
////import android.media.ToneGenerator
////import android.os.Bundle
////import android.os.VibrationEffect
////import android.os.Vibrator
////import androidx.activity.ComponentActivity
////import androidx.activity.compose.setContent
////import androidx.compose.foundation.layout.fillMaxSize
////import androidx.compose.material3.CircularProgressIndicator
////import androidx.compose.material3.MaterialTheme
////import androidx.compose.material3.Surface
////import androidx.compose.material3.Text
////import androidx.compose.runtime.*
////import androidx.compose.ui.Modifier
////import androidx.compose.ui.geometry.Offset
////import androidx.compose.ui.graphics.Color
////import androidx.compose.ui.platform.LocalContext
////import com.jmisabella.mazeq.layout.CellColors
////import com.jmisabella.mazeq.models.*
////import com.jmisabella.mazeq.screens.MazeRenderScreen
////import com.jmisabella.mazeq.screens.MazeRequestScreen
////import com.jmisabella.mazeq.ui.theme.MazerTheme
////import kotlinx.coroutines.Dispatchers
////import kotlinx.coroutines.launch
////import kotlinx.coroutines.withContext
////import kotlinx.serialization.encodeToString
////import kotlinx.serialization.json.Json
////import java.util.UUID
////import android.util.DisplayMetrics
////import kotlin.math.floor
////import kotlin.math.sqrt
////
////class MainActivity : ComponentActivity() {
////    override fun onCreate(savedInstanceState: Bundle?) {
////        super.onCreate(savedInstanceState)
////        setContent {
////            MazerTheme {
////                Surface(
////                    modifier = Modifier.fillMaxSize(),
////                    color = MaterialTheme.colorScheme.background
////                ) {
////                    ContentScreen()
////                }
////            }
////        }
////    }
////}
////
////@Composable
////fun ContentScreen() {
////    val coroutineScope = rememberCoroutineScope()
////    val context = LocalContext.current
////    val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
////    val toneGenerator = ToneGenerator(AudioManager.STREAM_MUSIC, 100)
////
////    var ffiIntegrationTestResult by remember { mutableStateOf(0) }
////    var mazeCells by remember { mutableStateOf<List<MazeCell>>(emptyList()) }
////    var mazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
////    var mazeGenerated by remember { mutableStateOf(false) }
////    var errorMessage by remember { mutableStateOf<String?>(null) }
////
////    var selectedSize by remember { mutableStateOf(CellSize.LARGE) }
////    var selectedMazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
////    var selectedAlgorithm by remember { mutableStateOf(MazeAlgorithm.RECURSIVE_BACKTRACKER) }
////    var showSolution by remember { mutableStateOf(false) }
////    var showHeatMap by remember { mutableStateOf(false) }
////    var showControls by remember { mutableStateOf(false) }
////    var padOffset by remember { mutableStateOf(Offset.Zero) }
////    var showCelebration by remember { mutableStateOf(false) }
////    var selectedPalette by remember { mutableStateOf(allPalettes.randomOrNull() ?: turquoisePalette) }
////    var mazeID by remember { mutableStateOf(UUID.randomUUID().toString()) }
////    var currentGrid by remember { mutableStateOf<Long?>(null) } // Grid* as Long
////    var defaultBackgroundColor by remember { mutableStateOf<Color>(CellColors.defaultBackgroundColors.randomOrNull() ?: Color.White) }
////    var didInitialRandomization by remember { mutableStateOf(false) }
////    var hasPlayedSoundThisSession by remember { mutableStateOf(false) }
////    var captureSteps by remember { mutableStateOf(false) }
////    var isGeneratingMaze by remember { mutableStateOf(false) }
////    var isAnimatingGeneration by remember { mutableStateOf(false) }
////    var generationSteps by remember { mutableStateOf<List<List<MazeCell>>>(emptyList()) }
////    var isLoading by remember { mutableStateOf(false) }
////    var optionalColor by remember { mutableStateOf<Color?>(null) }
////    var showHelp by remember { mutableStateOf(false) }
////
////    // Load saved preferences
////    LaunchedEffect(Unit) {
////        val sharedPrefs = context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
////        selectedSize = CellSize.values().find { it.value == sharedPrefs.getInt("lastSize", CellSize.MEDIUM.value) } ?: CellSize.MEDIUM
////        selectedMazeType = MazeType.values().find { it.ffiName == sharedPrefs.getString("lastMazeType", MazeType.ORTHOGONAL.ffiName) } ?: MazeType.ORTHOGONAL
////        selectedAlgorithm = MazeAlgorithm.values().find { it.name == sharedPrefs.getString("lastAlgorithm", MazeAlgorithm.RECURSIVE_BACKTRACKER.name) } ?: MazeAlgorithm.RECURSIVE_BACKTRACKER
////        showHeatMap = sharedPrefs.getBoolean("showHeatMap", false)
////
////        // Save initial preferences
////        sharedPrefs.edit().apply {
////            putInt("lastSize", selectedSize.value)
////            putString("lastMazeType", selectedMazeType.ffiName)
////            putString("lastAlgorithm", selectedAlgorithm.name)
////            putBoolean("showHeatMap", showHeatMap)
////            apply()
////        }
////
////        // Run FFI integration test
////        ffiIntegrationTestResult = MazerNative.mazerFfiIntegrationTest()
////        println("mazer_ffi_integration_test returned: $ffiIntegrationTestResult")
////        if (ffiIntegrationTestResult == 42) {
////            println("FFI integration test passed ✅")
////        } else {
////            println("FFI integration test failed ❌")
////        }
////    }
////
////    // Save preferences on change
////    LaunchedEffect(selectedSize) {
////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
////            .edit()
////            .putInt("lastSize", selectedSize.value)
////            .apply()
////    }
////    LaunchedEffect(selectedMazeType) {
////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
////            .edit()
////            .putString("lastMazeType", selectedMazeType.ffiName)
////            .apply()
////    }
////    LaunchedEffect(selectedAlgorithm) {
////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
////            .edit()
////            .putString("lastAlgorithm", selectedAlgorithm.name)
////            .apply()
////    }
////    LaunchedEffect(showHeatMap) {
////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
////            .edit()
////            .putBoolean("showHeatMap", showHeatMap)
////            .apply()
////    }
////
////    // Compute cell sizes
////    fun computeCellSizes(mazeType: MazeType, cellSize: CellSize): Pair<Float, Float> {
////        val baseSize = when (cellSize) {
////            CellSize.TINY -> 12f
////            CellSize.SMALL -> 20f
////            CellSize.MEDIUM -> 30f
////            CellSize.LARGE -> 40f
////        }
////        return when (mazeType) {
////            MazeType.UPSILON -> baseSize to baseSize * 0.8f
////            else -> baseSize to baseSize
////        }
////    }
////
////    // Random palette selection excluding current
////    fun randomPaletteExcluding(current: HeatMapPalette, allPalettes: List<HeatMapPalette>): HeatMapPalette {
////        val availablePalettes = allPalettes.filter { it != current }
////        return availablePalettes.randomOrNull() ?: current
////    }
////
////    // Random default background color excluding current
////    fun randomDefaultExcluding(current: Color, all: List<Color>): Color {
////        val others = all.filter { it != current }
////        return others.randomOrNull() ?: current
////    }
////
////    // Cleanup maze data
////    fun cleanupMazeData() {
////        currentGrid?.let { gridPtr ->
////            MazerNative.destroyMaze(gridPtr)
////            currentGrid = null
////        }
////        mazeCells = emptyList()
////        generationSteps = emptyList()
////        mazeGenerated = false
////        isAnimatingGeneration = false
////    }
////
////    // Celebrate victory
////    fun celebrateVictory() {
////        showCelebration = true
////        captureSteps = false
////
////        vibrator.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE))
////        toneGenerator.startTone(ToneGenerator.TONE_CDMA_CONFIRM, 200)
////
////        coroutineScope.launch {
////            kotlinx.coroutines.delay(3000)
////            withContext(Dispatchers.Main) {
////                showCelebration = false
////                if (mazeGenerated) {
////                    showSolution = false
////                    mazeID = UUID.randomUUID().toString()
////                    submitMazeRequest()
////                }
////            }
////        }
////    }
////
////    // Perform move
////    fun performMove(direction: String) {
////        if (showCelebration) return
////
////        val gridPtr = currentGrid ?: return
////
////        val tryDirections = when (mazeType) {
////            MazeType.ORTHOGONAL -> listOf(direction)
////            MazeType.DELTA -> when (direction) {
////                "UpperRight" -> listOf("UpperRight", "Right")
////                "LowerRight" -> listOf("LowerRight", "Right")
////                "UpperLeft" -> listOf("UpperLeft", "Left")
////                "LowerLeft" -> listOf("LowerLeft", "Left")
////                else -> listOf(direction)
////            }
////            MazeType.SIGMA -> when (direction) {
////                "UpperRight" -> listOf("UpperRight", "LowerRight")
////                "LowerRight" -> listOf("LowerRight", "UpperRight")
////                "UpperLeft" -> listOf("UpperLeft", "LowerLeft")
////                "LowerLeft" -> listOf("LowerLeft", "UpperLeft")
////                else -> listOf(direction)
////            }
////            MazeType.UPSILON -> listOf(direction)
////            MazeType.RHOMBIC -> listOf(direction)
////        }
////
////        var newGridPtr: Long? = null
////        for (dir in tryDirections) {
////            newGridPtr = MazerNative.makeMove(gridPtr, dir)
////            if (newGridPtr != 0L) break
////        }
////
////        if (newGridPtr == null || newGridPtr == 0L) return
////
////        toneGenerator.startTone(ToneGenerator.TONE_PROP_BEEP, 200)
////        vibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))
////
////        currentGrid = newGridPtr
////        val cellsPtr = MazerNative.getCells(newGridPtr)
////        if (cellsPtr == null) {
////            errorMessage = "Failed to retrieve updated maze."
////            return
////        }
////
////        val cells = cellsPtr.map { ffiCell ->
////            MazeCell(
////                x = ffiCell.x.toInt(),
////                y = ffiCell.y.toInt(),
////                mazeType = ffiCell.mazeType ?: "",
////                linked = ffiCell.linked?.toList() ?: emptyList(),
////                distance = ffiCell.distance,
////                isStart = ffiCell.isStart,
////                isGoal = ffiCell.isGoal,
////                isActive = ffiCell.isActive,
////                isVisited = ffiCell.isVisited,
////                hasBeenVisited = ffiCell.hasBeenVisited,
////                onSolutionPath = ffiCell.onSolutionPath,
////                orientation = ffiCell.orientation ?: "",
////                isSquare = ffiCell.isSquare
////            )
////        }
////
////        MazerNative.mazerFreeCells(cellsPtr, cellsPtr.size.toLong())
////
////        mazeCells = cells
////
////        if (!showCelebration && cells.any { it.isGoal && it.isActive }) {
////            celebrateVictory()
////        }
////    }
////
////    // Submit maze request
////    fun submitMazeRequest() {
////        coroutineScope.launch {
////            isLoading = true
////            withContext(Dispatchers.IO) {
////                // Cleanup existing grid
////                currentGrid?.let { gridPtr ->
////                    MazerNative.destroyMaze(gridPtr)
////                    currentGrid = null
////                }
////
////                val (squareCellSize, octagonCellSize) = computeCellSizes(selectedMazeType, selectedSize)
////
////                // Get screen dimensions
////                val metrics = context.resources.displayMetrics
////                val screenH = metrics.heightPixels / metrics.density
////                val screenW = metrics.widthPixels / metrics.density
////                val isSmallDevice = screenH <= 667
////
////                val perSidePad: Float = when (selectedMazeType) {
////                    MazeType.ORTHOGONAL -> 20f
////                    MazeType.UPSILON -> 12f
////                    else -> if (isSmallDevice) 50f else 100f
////                }
////
////                val totalVerticalPadding = perSidePad * 2
////                val controlArea = 80f
////                val availableH = screenH - controlArea - totalVerticalPadding
////                val drawableH = availableH // Simplified; adjust for insets if needed
////
////                val cellSize = if (selectedMazeType == MazeType.UPSILON) octagonCellSize else squareCellSize
////                val spacing = if (selectedMazeType == MazeType.UPSILON) (sqrt(2f) * 0.5f) * octagonCellSize else cellSize
////                val rowHeight = if (selectedMazeType == MazeType.UPSILON) octagonCellSize * (sqrt(2f) * 0.5f) else cellSize
////
////                val maxHeightRows = maxOf(1, floor(availableH / rowHeight).toInt())
////                val maxWidth = maxOf(1, floor(screenW / spacing).toInt())
////
////                var finalWidth: Int
////                var finalHeight: Int
////
////                if (selectedMazeType == MazeType.RHOMBIC) {
////                    val s = squareCellSize
////                    val diag = s * sqrt(2f)
////                    val pitch = diag * 0.5f
////                    finalWidth = maxOf(1, floor(screenW / diag).toInt())
////                    finalHeight = maxOf(1, floor(drawableH / pitch).toInt())
////                } else {
////                    finalWidth = if (selectedMazeType == MazeType.SIGMA) maxWidth / 3 else maxWidth
////                    finalHeight = if (selectedMazeType == MazeType.SIGMA) maxHeightRows / 3 else maxHeightRows
////                }
////
////                if (captureSteps && (finalWidth > 100 || finalHeight > 100)) {
////                    withContext(Dispatchers.Main) {
////                        errorMessage = "Show Maze Generation is only available for mazes with width and height ≤ 100."
////                        isLoading = false
////                    }
////                    return@withContext
////                }
////
////                val mazeRequest = MazeRequest(
////                    mazeType = selectedMazeType,
////                    width = finalWidth,
////                    height = finalHeight,
////                    algorithm = selectedAlgorithm,
////                    captureSteps = captureSteps
////                )
////
////                val jsonString = Json.encodeToString(mazeRequest)
////                println("Valid JSON: $jsonString")
////
////                val gridPtr = MazerNative.generateMaze(jsonString)
////                if (gridPtr == 0L) {
////                    withContext(Dispatchers.Main) {
////                        errorMessage = "Failed to generate maze."
////                        isLoading = false
////                    }
////                    return@withContext
////                }
////
////                currentGrid = gridPtr
////
////                val cellsPtr = MazerNative.getCells(gridPtr)
////                if (cellsPtr == null) {
////                    withContext(Dispatchers.Main) {
////                        errorMessage = "Failed to retrieve cells."
////                        isLoading = false
////                    }
////                    return@withContext
////                }
////
////                val cells = cellsPtr.map { ffiCell ->
////                    MazeCell(
////                        x = ffiCell.x.toInt(),
////                        y = ffiCell.y.toInt(),
////                        mazeType = ffiCell.mazeType ?: "",
////                        linked = ffiCell.linked?.toList() ?: emptyList(),
////                        distance = ffiCell.distance,
////                        isStart = ffiCell.isStart,
////                        isGoal = ffiCell.isGoal,
////                        isActive = ffiCell.isActive,
////                        isVisited = ffiCell.isVisited,
////                        hasBeenVisited = ffiCell.hasBeenVisited,
////                        onSolutionPath = ffiCell.onSolutionPath,
////                        orientation = ffiCell.orientation ?: "",
////                        isSquare = ffiCell.isSquare
////                    )
////                }
////
////                MazerNative.mazerFreeCells(cellsPtr, cellsPtr.size.toLong())
////
////                var steps: List<List<MazeCell>> = emptyList()
////                if (captureSteps) {
////                    val stepsCount = MazerNative.getGenerationStepsCount(gridPtr)
////                    steps = (0 until stepsCount).mapNotNull { stepIndex ->
////                        val stepCellsPtr = MazerNative.getGenerationStepCells(gridPtr, stepIndex)
////                        if (stepCellsPtr == null) {
////                            withContext(Dispatchers.Main) {
////                                errorMessage = "Failed to retrieve generation step cells."
////                                isLoading = false
////                            }
////                            null
////                        } else {
////                            val stepCells = stepCellsPtr.map { ffiCell ->
////                                MazeCell(
////                                    x = ffiCell.x.toInt(),
////                                    y = ffiCell.y.toInt(),
////                                    mazeType = ffiCell.mazeType ?: "",
////                                    linked = ffiCell.linked?.toList() ?: emptyList(),
////                                    distance = ffiCell.distance,
////                                    isStart = ffiCell.isStart,
////                                    isGoal = ffiCell.isGoal,
////                                    isActive = ffiCell.isActive,
////                                    isVisited = ffiCell.isVisited,
////                                    hasBeenVisited = ffiCell.hasBeenVisited,
////                                    onSolutionPath = ffiCell.onSolutionPath,
////                                    orientation = ffiCell.orientation ?: "",
////                                    isSquare = ffiCell.isSquare
////                                )
////                            }
////                            MazerNative.mazerFreeCells(stepCellsPtr, stepCellsPtr.size.toLong())
////                            stepCells
////                        }
////                    }
////                }
////
////                withContext(Dispatchers.Main) {
////                    mazeCells = cells
////                    mazeType = MazeType.fromFFIName(cells.firstOrNull()?.mazeType) ?: MazeType.ORTHOGONAL
////                    if (captureSteps) {
////                        generationSteps = steps
////                        isAnimatingGeneration = true
////                    } else {
////                        mazeGenerated = true
////                    }
////                    optionalColor = if ((0..1).random() == 1) {
////                        listOf(Color.Magenta, Color.Gray, Color.Yellow, Color.Blue, Color(0xFFA200FF), Color(0xFFFF9500)).randomOrNull()
////                    } else null
////                    isLoading = false
////                    errorMessage = null
////                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
////                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
////                }
////            }
////        }
////    }
////
////    // Main content rendering
////    if (isGeneratingMaze) {
////        CircularProgressIndicator(modifier = Modifier.fillMaxSize())
////    } else if (isAnimatingGeneration) {
////        Text("Maze Generation Animation Placeholder") // TODO: Implement MazeGenerationAnimationScreen
////    } else if (mazeGenerated) {
////        MazeRenderScreen(
////            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
////            showSolution = remember { mutableStateOf(showSolution) },
////            showHeatMap = remember { mutableStateOf(showHeatMap) },
////            showControls = remember { mutableStateOf(showControls) },
////            padOffset = remember { mutableStateOf(padOffset) },
////            selectedPalette = remember { mutableStateOf(selectedPalette) },
////            mazeID = mazeID,
////            defaultBackground = remember { mutableStateOf(defaultBackgroundColor) },
////            showHelp = remember { mutableStateOf(showHelp) },
////            mazeCells = mazeCells,
////            mazeType = mazeType,
////            cellSize = selectedSize,
////            optionalColor = optionalColor,
////            regenerateMaze = ::submitMazeRequest,
////            moveAction = { direction -> performMove(direction) },
////            cellSizes = computeCellSizes(selectedMazeType, selectedSize),
////            toggleHeatMap = {
////                showHeatMap = !showHeatMap
////                if (showHeatMap) {
////                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
////                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
////                }
////            },
////            cleanupMazeData = { cleanupMazeData() }
////        )
////    } else {
////        MazeRequestScreen(
////            mazeCells = remember { mutableStateOf(mazeCells) },
////            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
////            mazeType = remember { mutableStateOf(mazeType) },
////            selectedSize = remember { mutableStateOf(selectedSize) },
////            selectedMazeType = remember { mutableStateOf(selectedMazeType) },
////            selectedAlgorithm = remember { mutableStateOf(selectedAlgorithm) },
////            captureSteps = remember { mutableStateOf(captureSteps) },
////            submitMazeRequest = ::submitMazeRequest
////        )
////    }
////
////    if (isLoading) {
////        Text("Loading...")
////    }
////    if (showHelp) {
////        Text("Help Modal Placeholder") // TODO: Implement HelpModalScreen
////    }
////    if (showCelebration) {
////        Text("Celebration Placeholder") // TODO: Implement SparkleScreen
////    }
////}
////
//////package com.jmisabella.mazeq
//////
//////import android.content.Context
//////import android.media.AudioManager
//////import android.media.ToneGenerator
//////import android.os.Bundle
//////import android.os.VibrationEffect
//////import android.os.Vibrator
//////import androidx.activity.ComponentActivity
//////import androidx.activity.compose.setContent
//////import androidx.compose.foundation.layout.fillMaxSize
//////import androidx.compose.material3.CircularProgressIndicator
//////import androidx.compose.material3.MaterialTheme
//////import androidx.compose.material3.Surface
//////import androidx.compose.material3.Text
//////import androidx.compose.runtime.*
//////import androidx.compose.ui.Modifier
//////import androidx.compose.ui.geometry.Offset
//////import androidx.compose.ui.graphics.Color
//////import androidx.compose.ui.platform.LocalContext
//////import com.jmisabella.mazeq.layout.CellColors
//////import com.jmisabella.mazeq.models.*
//////import com.jmisabella.mazeq.screens.MazeRenderScreen
//////import com.jmisabella.mazeq.screens.MazeRequestScreen
//////import com.jmisabella.mazeq.ui.theme.MazerTheme
//////import kotlinx.coroutines.Dispatchers
//////import kotlinx.coroutines.launch
//////import kotlinx.coroutines.withContext
//////import kotlinx.serialization.encodeToString
//////import kotlinx.serialization.json.Json
//////import java.util.UUID
//////import android.util.DisplayMetrics
//////import kotlin.math.floor
//////import kotlin.math.sqrt
//////
//////class MainActivity : ComponentActivity() {
//////    override fun onCreate(savedInstanceState: Bundle?) {
//////        super.onCreate(savedInstanceState)
//////        setContent {
//////            MazerTheme {
//////                Surface(
//////                    modifier = Modifier.fillMaxSize(),
//////                    color = MaterialTheme.colorScheme.background
//////                ) {
//////                    ContentScreen()
//////                }
//////            }
//////        }
//////    }
//////}
//////
//////@Composable
//////fun ContentScreen() {
//////    val coroutineScope = rememberCoroutineScope()
//////    val context = LocalContext.current
//////    val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
//////    val toneGenerator = ToneGenerator(AudioManager.STREAM_MUSIC, 100)
//////
//////    var ffiIntegrationTestResult by remember { mutableStateOf(0) }
//////    var mazeCells by remember { mutableStateOf<List<MazeCell>>(emptyList()) }
//////    var mazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
//////    var mazeGenerated by remember { mutableStateOf(false) }
//////    var errorMessage by remember { mutableStateOf<String?>(null) }
//////
//////    var selectedSize by remember { mutableStateOf(CellSize.LARGE) }
//////    var selectedMazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
//////    var selectedAlgorithm by remember { mutableStateOf(MazeAlgorithm.RECURSIVE_BACKTRACKER) }
//////    var showSolution by remember { mutableStateOf(false) }
//////    var showHeatMap by remember { mutableStateOf(false) }
//////    var showControls by remember { mutableStateOf(false) }
//////    var padOffset by remember { mutableStateOf(Offset.Zero) }
//////    var showCelebration by remember { mutableStateOf(false) }
//////    var selectedPalette by remember { mutableStateOf(allPalettes.randomOrNull() ?: turquoisePalette) }
//////    var mazeID by remember { mutableStateOf(UUID.randomUUID().toString()) }
//////    var currentGrid by remember { mutableStateOf<Long?>(null) } // Grid* as Long
//////    var defaultBackgroundColor by remember { mutableStateOf<Color>(CellColors.defaultBackgroundColors.randomOrNull() ?: Color.White) }
//////    var didInitialRandomization by remember { mutableStateOf(false) }
//////    var hasPlayedSoundThisSession by remember { mutableStateOf(false) }
//////    var captureSteps by remember { mutableStateOf(false) }
//////    var isGeneratingMaze by remember { mutableStateOf(false) }
//////    var isAnimatingGeneration by remember { mutableStateOf(false) }
//////    var generationSteps by remember { mutableStateOf<List<List<MazeCell>>>(emptyList()) }
//////    var isLoading by remember { mutableStateOf(false) }
//////    var optionalColor by remember { mutableStateOf<Color?>(null) }
//////    var showHelp by remember { mutableStateOf(false) }
//////
//////    // Load saved preferences
//////    LaunchedEffect(Unit) {
//////        val sharedPrefs = context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//////        selectedSize = CellSize.values().find { it.value == sharedPrefs.getInt("lastSize", CellSize.MEDIUM.value) } ?: CellSize.MEDIUM
//////        selectedMazeType = MazeType.values().find { it.ffiName == sharedPrefs.getString("lastMazeType", MazeType.ORTHOGONAL.ffiName) } ?: MazeType.ORTHOGONAL
//////        selectedAlgorithm = MazeAlgorithm.values().find { it.name == sharedPrefs.getString("lastAlgorithm", MazeAlgorithm.RECURSIVE_BACKTRACKER.name) } ?: MazeAlgorithm.RECURSIVE_BACKTRACKER
//////        showHeatMap = sharedPrefs.getBoolean("showHeatMap", false)
//////
//////        // Save initial preferences
//////        sharedPrefs.edit().apply {
//////            putInt("lastSize", selectedSize.value)
//////            putString("lastMazeType", selectedMazeType.ffiName)
//////            putString("lastAlgorithm", selectedAlgorithm.name)
//////            putBoolean("showHeatMap", showHeatMap)
//////            apply()
//////        }
//////
//////        // Run FFI integration test
//////        ffiIntegrationTestResult = MazerNative.mazerFfiIntegrationTest()
//////        println("mazer_ffi_integration_test returned: $ffiIntegrationTestResult")
//////        if (ffiIntegrationTestResult == 42) {
//////            println("FFI integration test passed ✅")
//////        } else {
//////            println("FFI integration test failed ❌")
//////        }
//////    }
//////
//////    // Save preferences on change
//////    LaunchedEffect(selectedSize) {
//////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//////            .edit()
//////            .putInt("lastSize", selectedSize.value)
//////            .apply()
//////    }
//////    LaunchedEffect(selectedMazeType) {
//////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//////            .edit()
//////            .putString("lastMazeType", selectedMazeType.ffiName)
//////            .apply()
//////    }
//////    LaunchedEffect(selectedAlgorithm) {
//////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//////            .edit()
//////            .putString("lastAlgorithm", selectedAlgorithm.name)
//////            .apply()
//////    }
//////    LaunchedEffect(showHeatMap) {
//////        context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
//////            .edit()
//////            .putBoolean("showHeatMap", showHeatMap)
//////            .apply()
//////    }
//////
//////    // Compute cell sizes
//////    fun computeCellSizes(mazeType: MazeType, cellSize: CellSize): Pair<Float, Float> {
//////        val baseSize = when (cellSize) {
//////            CellSize.TINY -> 12f
//////            CellSize.SMALL -> 20f
//////            CellSize.MEDIUM -> 30f
//////            CellSize.LARGE -> 40f
//////        }
//////        return when (mazeType) {
//////            MazeType.UPSILON -> baseSize to baseSize * 0.8f
//////            else -> baseSize to baseSize
//////        }
//////    }
//////
//////    // Random palette selection excluding current
//////    fun randomPaletteExcluding(current: HeatMapPalette, allPalettes: List<HeatMapPalette>): HeatMapPalette {
//////        val availablePalettes = allPalettes.filter { it != current }
//////        return availablePalettes.randomOrNull() ?: current
//////    }
//////
//////    // Random default background color excluding current
//////    fun randomDefaultExcluding(current: Color, all: List<Color>): Color {
//////        val others = all.filter { it != current }
//////        return others.randomOrNull() ?: current
//////    }
//////
//////    // Cleanup maze data
//////    fun cleanupMazeData() {
//////        currentGrid?.let { gridPtr ->
//////            MazerNative.destroyMaze(gridPtr)
//////            currentGrid = null
//////        }
//////        mazeCells = emptyList()
//////        generationSteps = emptyList()
//////        mazeGenerated = false
//////        isAnimatingGeneration = false
//////    }
//////
//////    // Celebrate victory
//////    fun celebrateVictory() {
//////        showCelebration = true
//////        captureSteps = false
//////
//////        vibrator.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE))
//////        toneGenerator.startTone(ToneGenerator.TONE_CDMA_CONFIRM, 200)
//////
//////        coroutineScope.launch {
//////            kotlinx.coroutines.delay(3000)
//////            withContext(Dispatchers.Main) {
//////                showCelebration = false
//////                if (mazeGenerated) {
//////                    showSolution = false
//////                    mazeID = UUID.randomUUID().toString()
//////                    submitMazeRequest()
//////                }
//////            }
//////        }
//////    }
//////
//////    // Perform move
//////    fun performMove(direction: String) {
//////        if (showCelebration) return
//////
//////        val gridPtr = currentGrid ?: return
//////
//////        val tryDirections = when (mazeType) {
//////            MazeType.ORTHOGONAL -> listOf(direction)
//////            MazeType.DELTA -> when (direction) {
//////                "UpperRight" -> listOf("UpperRight", "Right")
//////                "LowerRight" -> listOf("LowerRight", "Right")
//////                "UpperLeft" -> listOf("UpperLeft", "Left")
//////                "LowerLeft" -> listOf("LowerLeft", "Left")
//////                else -> listOf(direction)
//////            }
//////            MazeType.SIGMA -> when (direction) {
//////                "UpperRight" -> listOf("UpperRight", "LowerRight")
//////                "LowerRight" -> listOf("LowerRight", "UpperRight")
//////                "UpperLeft" -> listOf("UpperLeft", "LowerLeft")
//////                "LowerLeft" -> listOf("LowerLeft", "UpperLeft")
//////                else -> listOf(direction)
//////            }
//////            MazeType.UPSILON -> listOf(direction)
//////            MazeType.RHOMBIC -> listOf(direction)
//////        }
//////
//////        var newGridPtr: Long? = null
//////        for (dir in tryDirections) {
//////            newGridPtr = MazerNative.makeMove(gridPtr, dir)
//////            if (newGridPtr != 0L) break
//////        }
//////
//////        if (newGridPtr == null || newGridPtr == 0L) return
//////
//////        toneGenerator.startTone(ToneGenerator.TONE_PROP_BEEP, 200)
//////        vibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))
//////
//////        currentGrid = newGridPtr
//////        val cellsPtr = MazerNative.getCells(newGridPtr)
//////        if (cellsPtr == null) {
//////            errorMessage = "Failed to retrieve updated maze."
//////            return
//////        }
//////
//////        val cells = cellsPtr.map { ffiCell ->
//////            MazeCell(
//////                x = ffiCell.x.toInt(),
//////                y = ffiCell.y.toInt(),
//////                mazeType = ffiCell.mazeType ?: "",
//////                linked = ffiCell.linked?.toList() ?: emptyList(),
//////                distance = ffiCell.distance,
//////                isStart = ffiCell.isStart,
//////                isGoal = ffiCell.isGoal,
//////                isActive = ffiCell.isActive,
//////                isVisited = ffiCell.isVisited,
//////                hasBeenVisited = ffiCell.hasBeenVisited,
//////                onSolutionPath = ffiCell.onSolutionPath,
//////                orientation = ffiCell.orientation ?: "",
//////                isSquare = ffiCell.isSquare
//////            )
//////        }
//////
//////        MazerNative.freeCells(cellsPtr, cellsPtr.size.toLong())
//////
//////        mazeCells = cells
//////
//////        if (!showCelebration && cells.any { it.isGoal && it.isActive }) {
//////            celebrateVictory()
//////        }
//////    }
//////
//////    // Submit maze request
//////    fun submitMazeRequest() {
//////        coroutineScope.launch {
//////            isLoading = true
//////            withContext(Dispatchers.IO) {
//////                // Cleanup existing grid
//////                currentGrid?.let { gridPtr ->
//////                    MazerNative.destroyMaze(gridPtr)
//////                    currentGrid = null
//////                }
//////
//////                val (squareCellSize, octagonCellSize) = computeCellSizes(selectedMazeType, selectedSize)
//////
//////                // Get screen dimensions
//////                val metrics = context.resources.displayMetrics
//////                val screenH = metrics.heightPixels / metrics.density
//////                val screenW = metrics.widthPixels / metrics.density
//////                val isSmallDevice = screenH <= 667
//////
//////                val perSidePad: Float = when (selectedMazeType) {
//////                    MazeType.ORTHOGONAL -> 20f
//////                    MazeType.UPSILON -> 12f
//////                    else -> if (isSmallDevice) 50f else 100f
//////                }
//////
//////                val totalVerticalPadding = perSidePad * 2
//////                val controlArea = 80f
//////                val availableH = screenH - controlArea - totalVerticalPadding
//////                val drawableH = availableH // Simplified; adjust for insets if needed
//////
//////                val cellSize = if (selectedMazeType == MazeType.UPSILON) octagonCellSize else squareCellSize
//////                val spacing = if (selectedMazeType == MazeType.UPSILON) (sqrt(2f) * 0.5f) * octagonCellSize else cellSize
//////                val rowHeight = if (selectedMazeType == MazeType.UPSILON) octagonCellSize * (sqrt(2f) * 0.5f) else cellSize
//////
//////                val maxHeightRows = maxOf(1, floor(availableH / rowHeight).toInt())
//////                val maxWidth = maxOf(1, floor(screenW / spacing).toInt())
//////
//////                var finalWidth: Int
//////                var finalHeight: Int
//////
//////                if (selectedMazeType == MazeType.RHOMBIC) {
//////                    val s = squareCellSize
//////                    val diag = s * sqrt(2f)
//////                    val pitch = diag * 0.5f
//////                    finalWidth = maxOf(1, floor(screenW / diag).toInt())
//////                    finalHeight = maxOf(1, floor(drawableH / pitch).toInt())
//////                } else {
//////                    finalWidth = if (selectedMazeType == MazeType.SIGMA) maxWidth / 3 else maxWidth
//////                    finalHeight = if (selectedMazeType == MazeType.SIGMA) maxHeightRows / 3 else maxHeightRows
//////                }
//////
//////                if (captureSteps && (finalWidth > 100 || finalHeight > 100)) {
//////                    withContext(Dispatchers.Main) {
//////                        errorMessage = "Show Maze Generation is only available for mazes with width and height ≤ 100."
//////                        isLoading = false
//////                    }
//////                    return@withContext
//////                }
//////
//////                val mazeRequest = MazeRequest(
//////                    mazeType = selectedMazeType,
//////                    width = finalWidth,
//////                    height = finalHeight,
//////                    algorithm = selectedAlgorithm,
//////                    captureSteps = captureSteps
//////                )
//////
//////                val jsonString = Json.encodeToString(mazeRequest)
//////                println("Valid JSON: $jsonString")
//////
//////                val gridPtr = MazerNative.generateMaze(jsonString)
//////                if (gridPtr == 0L) {
//////                    withContext(Dispatchers.Main) {
//////                        errorMessage = "Failed to generate maze."
//////                        isLoading = false
//////                    }
//////                    return@withContext
//////                }
//////
//////                currentGrid = gridPtr
//////
//////                val cellsPtr = MazerNative.getCells(gridPtr)
//////                if (cellsPtr == null) {
//////                    withContext(Dispatchers.Main) {
//////                        errorMessage = "Failed to retrieve cells."
//////                        isLoading = false
//////                    }
//////                    return@withContext
//////                }
//////
//////                val cells = cellsPtr.map { ffiCell ->
//////                    MazeCell(
//////                        x = ffiCell.x.toInt(),
//////                        y = ffiCell.y.toInt(),
//////                        mazeType = ffiCell.mazeType ?: "",
//////                        linked = ffiCell.linked?.toList() ?: emptyList(),
//////                        distance = ffiCell.distance,
//////                        isStart = ffiCell.isStart,
//////                        isGoal = ffiCell.isGoal,
//////                        isActive = ffiCell.isActive,
//////                        isVisited = ffiCell.isVisited,
//////                        hasBeenVisited = ffiCell.hasBeenVisited,
//////                        onSolutionPath = ffiCell.onSolutionPath,
//////                        orientation = ffiCell.orientation ?: "",
//////                        isSquare = ffiCell.isSquare
//////                    )
//////                }
//////
//////                MazerNative.freeCells(cellsPtr, cellsPtr.size.toLong())
//////
//////                var steps: List<List<MazeCell>> = emptyList()
//////                if (captureSteps) {
//////                    val stepsCount = MazerNative.getGenerationStepsCount(gridPtr)
//////                    steps = (0 until stepsCount).map { stepIndex ->
//////                        val stepCellsPtr = MazerNative.getGenerationStepCells(gridPtr, stepIndex)
//////                        if (stepCellsPtr == null) {
//////                            withContext(Dispatchers.Main) {
//////                                errorMessage = "Failed to retrieve generation step cells."
//////                                isLoading = false
//////                            }
//////                            return@withContext emptyList<MazeCell>()
//////                        }
//////                        val stepCells = stepCellsPtr.map { ffiCell ->
//////                            MazeCell(
//////                                x = ffiCell.x.toInt(),
//////                                y = ffiCell.y.toInt(),
//////                                mazeType = ffiCell.mazeType ?: "",
//////                                linked = ffiCell.linked?.toList() ?: emptyList(),
//////                                distance = ffiCell.distance,
//////                                isStart = ffiCell.isStart,
//////                                isGoal = ffiCell.isGoal,
//////                                isActive = ffiCell.isActive,
//////                                isVisited = ffiCell.isVisited,
//////                                hasBeenVisited = ffiCell.hasBeenVisited,
//////                                onSolutionPath = ffiCell.onSolutionPath,
//////                                orientation = ffiCell.orientation ?: "",
//////                                isSquare = ffiCell.isSquare
//////                            )
//////                        }
//////                        MazerNative.freeCells(stepCellsPtr, stepCellsPtr.size.toLong())
//////                        stepCells
//////                    }.filter { it.isNotEmpty() }
//////                }
//////
//////                withContext(Dispatchers.Main) {
//////                    mazeCells = cells
//////                    mazeType = MazeType.fromFFIName(cells.firstOrNull()?.mazeType) ?: MazeType.ORTHOGONAL
//////                    if (captureSteps) {
//////                        generationSteps = steps
//////                        isAnimatingGeneration = true
//////                    } else {
//////                        mazeGenerated = true
//////                    }
//////                    optionalColor = if ((0..1).random() == 1) {
//////                        listOf(Color.Magenta, Color.Gray, Color.Yellow, Color.Blue, Color(0xFFA200FF), Color(0xFFFF9500)).randomOrNull()
//////                    } else null
//////                    isLoading = false
//////                    errorMessage = null
//////                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
//////                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
//////                }
//////            }
//////        }
//////    }
//////
//////    // Main content rendering
//////    if (isGeneratingMaze) {
//////        CircularProgressIndicator(modifier = Modifier.fillMaxSize())
//////    } else if (isAnimatingGeneration) {
//////        Text("Maze Generation Animation Placeholder") // TODO: Implement MazeGenerationAnimationScreen
//////    } else if (mazeGenerated) {
//////        MazeRenderScreen(
//////            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
//////            showSolution = remember { mutableStateOf(showSolution) },
//////            showHeatMap = remember { mutableStateOf(showHeatMap) },
//////            showControls = remember { mutableStateOf(showControls) },
//////            padOffset = remember { mutableStateOf(padOffset) },
//////            selectedPalette = remember { mutableStateOf(selectedPalette) },
//////            mazeID = mazeID,
//////            defaultBackground = remember { mutableStateOf(defaultBackgroundColor) },
//////            showHelp = remember { mutableStateOf(showHelp) },
//////            mazeCells = mazeCells,
//////            mazeType = mazeType,
//////            cellSize = selectedSize,
//////            optionalColor = optionalColor,
//////            regenerateMaze = { submitMazeRequest() },
//////            moveAction = { direction -> performMove(direction) },
//////            cellSizes = computeCellSizes(selectedMazeType, selectedSize),
//////            toggleHeatMap = {
//////                showHeatMap = !showHeatMap
//////                if (showHeatMap) {
//////                    selectedPalette = randomPaletteExcluding(selectedPalette, allPalettes)
//////                    defaultBackgroundColor = randomDefaultExcluding(defaultBackgroundColor, CellColors.defaultBackgroundColors)
//////                }
//////            },
//////            cleanupMazeData = { cleanupMazeData() }
//////        )
//////    } else {
//////        MazeRequestScreen(
//////            mazeCells = remember { mutableStateOf(mazeCells) },
//////            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
//////            mazeType = remember { mutableStateOf(mazeType) },
//////            selectedSize = remember { mutableStateOf(selectedSize) },
//////            selectedMazeType = remember { mutableStateOf(selectedMazeType) },
//////            selectedAlgorithm = remember { mutableStateOf(selectedAlgorithm) },
//////            captureSteps = remember { mutableStateOf(captureSteps) },
//////            submitMazeRequest = { submitMazeRequest() }
//////        )
//////    }
//////
//////    if (isLoading) {
//////        Text("Loading...")
//////    }
//////    if (showHelp) {
//////        Text("Help Modal Placeholder") // TODO: Implement HelpModalScreen
//////    }
//////    if (showCelebration) {
//////        Text("Celebration Placeholder") // TODO: Implement SparkleScreen
//////    }
//////}
//////
////////// MainActivity.kt
////////package com.jmisabella.mazeq
////////
////////import android.os.Bundle
////////import androidx.activity.ComponentActivity
////////import androidx.activity.compose.setContent
////////import androidx.compose.foundation.layout.fillMaxSize
////////import androidx.compose.material3.CircularProgressIndicator
////////import androidx.compose.material3.MaterialTheme
////////import androidx.compose.material3.Surface
////////import androidx.compose.material3.Text
////////import androidx.compose.runtime.*
////////import androidx.compose.ui.Modifier
////////import androidx.compose.ui.geometry.Offset
////////import androidx.compose.ui.graphics.Color
////////import com.jmisabella.mazeq.layout.CellColors
////////import com.jmisabella.mazeq.models.*
////////import com.jmisabella.mazeq.screens.MazeRequestScreen
////////import com.jmisabella.mazeq.ui.theme.MazerTheme
////////import java.util.UUID
////////
////////class MainActivity : ComponentActivity() {
////////    override fun onCreate(savedInstanceState: Bundle?) {
////////        super.onCreate(savedInstanceState)
////////        setContent {
////////            MazerTheme {
////////                Surface(
////////                    modifier = Modifier.fillMaxSize(),
////////                    color = MaterialTheme.colorScheme.background
////////                ) {
////////                    ContentScreen()
////////                }
////////            }
////////        }
////////    }
////////}
////////
////////@Composable
////////fun ContentScreen() {
////////    // Ported states from ContentView.swift
////////    var ffiIntegrationTestResult by remember { mutableStateOf(0) } // Assuming Int
////////    var mazeCells by remember { mutableStateOf<List<MazeCell>>(emptyList()) }
////////    var mazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
////////    var mazeGenerated by remember { mutableStateOf(false) }
////////    var errorMessage by remember { mutableStateOf<String?>(null) }
////////
////////    var selectedSize by remember { mutableStateOf(CellSize.LARGE) }
////////    var selectedMazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
////////    var selectedAlgorithm by remember { mutableStateOf(MazeAlgorithm.RECURSIVE_BACKTRACKER) }
////////    var showSolution by remember { mutableStateOf(false) }
////////    var showHeatMap by remember { mutableStateOf(false) }
////////    var showControls by remember { mutableStateOf(false) }
////////    var padOffset by remember { mutableStateOf(Offset.Zero) } // Equivalent to CGSize
////////    var showCelebration by remember { mutableStateOf(false) }
////////    var selectedPalette by remember { mutableStateOf(allPalettes.randomOrNull() ?: turquoisePalette) }
////////    var mazeID by remember { mutableStateOf(UUID.randomUUID().toString()) }
////////    var currentGrid by remember { mutableStateOf<Long?>(null) } // Assuming pointer as Long for simplicity; adjust for FFI
////////    var defaultBackgroundColor by remember { mutableStateOf<Color>(CellColors.defaultBackgroundColors.randomOrNull() ?: Color.White) }
////////    var didInitialRandomization by remember { mutableStateOf(false) }
////////    var hasPlayedSoundThisSession by remember { mutableStateOf(false) }
////////    var captureSteps by remember { mutableStateOf(false) }
////////    var isGeneratingMaze by remember { mutableStateOf(false) }
////////    var isAnimatingGeneration by remember { mutableStateOf(false) }
////////    var generationSteps by remember { mutableStateOf<List<List<MazeCell>>>(emptyList()) }
////////    var isLoading by remember { mutableStateOf(false) }
////////    var optionalColor by remember { mutableStateOf<Color?>(null) }
////////    var showHelp by remember { mutableStateOf(false) }
////////
////////    // TODO: Port onAppear logic, FFI integration test, UserDefaults (use SharedPreferences on Android), scenePhase (use lifecycle observers), etc.
////////    // For now, focus on initial rendering
////////
////////    // Conditional rendering mirroring ContentView's mainContentView
////////    if (isGeneratingMaze) {
////////        // ProgressView equivalent
////////        CircularProgressIndicator(modifier = Modifier.fillMaxSize())
////////    } else if (isAnimatingGeneration) {
////////        // Placeholder for MazeGenerationAnimationScreen (convert later)
////////        Text("Maze Generation Animation Placeholder")
////////    } else if (mazeGenerated) {
////////        // Placeholder for MazeRenderScreen (convert later)
////////        Text("Maze Render Placeholder")
////////    } else {
////////        MazeRequestScreen(
////////            mazeCells = remember { mutableStateOf(mazeCells) },
////////            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
////////            mazeType = remember { mutableStateOf(mazeType) },
////////            selectedSize = remember { mutableStateOf(selectedSize) },
////////            selectedMazeType = remember { mutableStateOf(selectedMazeType) },
////////            selectedAlgorithm = remember { mutableStateOf(selectedAlgorithm) },
////////            captureSteps = remember { mutableStateOf(captureSteps) },
////////            submitMazeRequest = {
////////                // Port submitMazeRequest logic here
////////                // For now, simulate generation
////////                mazeGenerated = true
////////            }
////////        )
////////    }
////////
////////    // TODO: Add overlays for loading, help, celebration, etc.
////////    if (isLoading) {
////////        // LoadingOverlay equivalent
////////        Text("Loading...")
////////    }
////////    if (showHelp) {
////////        // HelpModal equivalent
////////        Text("Help Modal Placeholder")
////////    }
////////    if (showCelebration) {
////////        // SparkleView equivalent
////////        Text("Celebration Placeholder")
////////    }
////////}
////////
//////////package com.jmisabella.mazeq
//////////
//////////import android.os.Bundle
//////////import androidx.activity.ComponentActivity
//////////import androidx.activity.compose.setContent
//////////import androidx.activity.enableEdgeToEdge
//////////import androidx.compose.foundation.layout.fillMaxSize
//////////import androidx.compose.foundation.layout.padding
//////////import androidx.compose.material3.Scaffold
//////////import androidx.compose.material3.Text
//////////import androidx.compose.runtime.Composable
//////////import androidx.compose.ui.Modifier
//////////import androidx.compose.ui.tooling.preview.Preview
//////////import com.jmisabella.mazeq.ui.theme.MazerandroidTheme
//////////import androidx.compose.runtime.mutableStateOf
//////////import androidx.compose.runtime.remember
//////////
//////////class MainActivity : ComponentActivity() {
//////////    override fun onCreate(savedInstanceState: Bundle?) {
//////////        super.onCreate(savedInstanceState)
//////////        enableEdgeToEdge()
//////////        setContent {
//////////            val testResult = remember { mutableStateOf(0) }
//////////            testResult.value = MazerNative.mazerFfiIntegrationTest()
//////////            Text(
//////////                text = "FFI Test Result: ${testResult.value}",
//////////                modifier = Modifier.fillMaxSize()
//////////            )
//////////        }
//////////    }
//////////}
//////////
//////////@Composable
//////////fun Greeting(name: String, modifier: Modifier = Modifier) {
//////////    Text(
//////////        text = "Hello $name!",
//////////        modifier = modifier
//////////    )
//////////}
//////////
//////////@Preview(showBackground = true)
//////////@Composable
//////////fun GreetingPreview() {
//////////    MazerandroidTheme {
//////////        Greeting("Android")
//////////    }
//////////}