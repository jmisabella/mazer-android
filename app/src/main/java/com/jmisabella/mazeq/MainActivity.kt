// MainActivity.kt
package com.jmisabella.mazeq

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import com.jmisabella.mazeq.layout.CellColors
import com.jmisabella.mazeq.models.*
import com.jmisabella.mazeq.screens.MazeRequestScreen
import com.jmisabella.mazeq.ui.theme.MazerTheme
import java.util.UUID

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MazerTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    ContentScreen()
                }
            }
        }
    }
}

@Composable
fun ContentScreen() {
    // Ported states from ContentView.swift
    var ffiIntegrationTestResult by remember { mutableStateOf(0) } // Assuming Int
    var mazeCells by remember { mutableStateOf<List<MazeCell>>(emptyList()) }
    var mazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
    var mazeGenerated by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf<String?>(null) }

    var selectedSize by remember { mutableStateOf(CellSize.LARGE) }
    var selectedMazeType by remember { mutableStateOf(MazeType.ORTHOGONAL) }
    var selectedAlgorithm by remember { mutableStateOf(MazeAlgorithm.RECURSIVE_BACKTRACKER) }
    var showSolution by remember { mutableStateOf(false) }
    var showHeatMap by remember { mutableStateOf(false) }
    var showControls by remember { mutableStateOf(false) }
    var padOffset by remember { mutableStateOf(Offset.Zero) } // Equivalent to CGSize
    var showCelebration by remember { mutableStateOf(false) }
    var selectedPalette by remember { mutableStateOf(allPalettes.randomOrNull() ?: turquoisePalette) }
    var mazeID by remember { mutableStateOf(UUID.randomUUID().toString()) }
    var currentGrid by remember { mutableStateOf<Long?>(null) } // Assuming pointer as Long for simplicity; adjust for FFI
    var defaultBackgroundColor by remember { mutableStateOf<Color>(CellColors.defaultBackgroundColors.randomOrNull() ?: Color.White) }
    var didInitialRandomization by remember { mutableStateOf(false) }
    var hasPlayedSoundThisSession by remember { mutableStateOf(false) }
    var captureSteps by remember { mutableStateOf(false) }
    var isGeneratingMaze by remember { mutableStateOf(false) }
    var isAnimatingGeneration by remember { mutableStateOf(false) }
    var generationSteps by remember { mutableStateOf<List<List<MazeCell>>>(emptyList()) }
    var isLoading by remember { mutableStateOf(false) }
    var optionalColor by remember { mutableStateOf<Color?>(null) }
    var showHelp by remember { mutableStateOf(false) }

    // TODO: Port onAppear logic, FFI integration test, UserDefaults (use SharedPreferences on Android), scenePhase (use lifecycle observers), etc.
    // For now, focus on initial rendering

    // Conditional rendering mirroring ContentView's mainContentView
    if (isGeneratingMaze) {
        // ProgressView equivalent
        CircularProgressIndicator(modifier = Modifier.fillMaxSize())
    } else if (isAnimatingGeneration) {
        // Placeholder for MazeGenerationAnimationScreen (convert later)
        Text("Maze Generation Animation Placeholder")
    } else if (mazeGenerated) {
        // Placeholder for MazeRenderScreen (convert later)
        Text("Maze Render Placeholder")
    } else {
        MazeRequestScreen(
            mazeCells = remember { mutableStateOf(mazeCells) },
            mazeGenerated = remember { mutableStateOf(mazeGenerated) },
            mazeType = remember { mutableStateOf(mazeType) },
            selectedSize = remember { mutableStateOf(selectedSize) },
            selectedMazeType = remember { mutableStateOf(selectedMazeType) },
            selectedAlgorithm = remember { mutableStateOf(selectedAlgorithm) },
            captureSteps = remember { mutableStateOf(captureSteps) },
            submitMazeRequest = {
                // Port submitMazeRequest logic here
                // For now, simulate generation
                mazeGenerated = true
            }
        )
    }

    // TODO: Add overlays for loading, help, celebration, etc.
    if (isLoading) {
        // LoadingOverlay equivalent
        Text("Loading...")
    }
    if (showHelp) {
        // HelpModal equivalent
        Text("Help Modal Placeholder")
    }
    if (showCelebration) {
        // SparkleView equivalent
        Text("Celebration Placeholder")
    }
}

//package com.jmisabella.mazeq
//
//import android.os.Bundle
//import androidx.activity.ComponentActivity
//import androidx.activity.compose.setContent
//import androidx.activity.enableEdgeToEdge
//import androidx.compose.foundation.layout.fillMaxSize
//import androidx.compose.foundation.layout.padding
//import androidx.compose.material3.Scaffold
//import androidx.compose.material3.Text
//import androidx.compose.runtime.Composable
//import androidx.compose.ui.Modifier
//import androidx.compose.ui.tooling.preview.Preview
//import com.jmisabella.mazeq.ui.theme.MazerandroidTheme
//import androidx.compose.runtime.mutableStateOf
//import androidx.compose.runtime.remember
//
//class MainActivity : ComponentActivity() {
//    override fun onCreate(savedInstanceState: Bundle?) {
//        super.onCreate(savedInstanceState)
//        enableEdgeToEdge()
//        setContent {
//            val testResult = remember { mutableStateOf(0) }
//            testResult.value = MazerNative.mazerFfiIntegrationTest()
//            Text(
//                text = "FFI Test Result: ${testResult.value}",
//                modifier = Modifier.fillMaxSize()
//            )
//        }
//    }
//}
//
//@Composable
//fun Greeting(name: String, modifier: Modifier = Modifier) {
//    Text(
//        text = "Hello $name!",
//        modifier = modifier
//    )
//}
//
//@Preview(showBackground = true)
//@Composable
//fun GreetingPreview() {
//    MazerandroidTheme {
//        Greeting("Android")
//    }
//}